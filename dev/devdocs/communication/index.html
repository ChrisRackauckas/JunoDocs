<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Communication · Juno Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.svg" alt="Juno Documentation logo"/></a><h1>Juno Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/installation/">Installation Instructions</a></li><li><a class="toctext" href="../../man/basic_usage/">Basic Usage</a></li><li><a class="toctext" href="../../man/debugging/">Debugging</a></li><li><a class="toctext" href="../../man/faq/">FAQ</a></li><li><a class="toctext" href="../../man/juno_frontend/">The Juno.jl Front-End</a></li><li><a class="toctext" href="../../man/info_developer/">Information for Package Developers</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../contributor_guide/">Contributor Guide</a></li><li><a class="toctext" href="../dev_install/">Developer Installation Instructions</a></li><li><a class="toctext" href="../package_info/">Juno Package Information</a></li><li><a class="toctext" href="../juno_ci/">Juno&#39;s CI</a></li><li class="current"><a class="toctext" href>Communication</a><ul class="internal"><li><a class="toctext" href="#Sending-messages-from-Atom-1">Sending messages from Atom</a></li><li><a class="toctext" href="#Sending-messages-from-Julia-1">Sending messages from Julia</a></li><li><a class="toctext" href="#Debugging-and-Learning-1">Debugging and Learning</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li><a href>Communication</a></li></ul><a class="edit-page" href="https://github.com/JunoLab/JunoDocs.jl/blob/master/docs/src/devdocs/communication.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Communication</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Communication-1" href="#Communication-1">Communication</a></h1><p>Juno works by booting a Julia client from Atom. When Julia starts it connects to Atom over a TCP port, and from that point on Julia and Atom can each send messages to each other. Messages are JSON objects, with a type header to tell the receiver how the message should be handled.</p><p>The code handling low-level communication is kept in <a href="https://github.com/JunoLab/atom-julia-client/blob/master/lib/connection/client.coffee">client.coffee</a> and <a href="https://github.com/JunoLab/Atom.jl/blob/master/src/comm.jl">comm.jl</a>. However, the details of those files aren&#39;t particularly important – you only need to understand the communication API, which we&#39;ll go over here.</p><h2><a class="nav-anchor" id="Sending-messages-from-Atom-1" href="#Sending-messages-from-Atom-1">Sending messages from Atom</a></h2><p>Communication works by sending messages with an appropriate type on one side and registering handlers for that type on the other. The handler then takes some action and returns data to the original sender. For example, on the Atom side messages are sent in CoffeeScript as follows:</p><pre><code class="language-coffeescript">client.msg &#39;eval&#39;, &#39;2+2&#39;</code></pre><p>On the Julia side, we need to set up a handler for this message, which happens as follows:</p><pre><code class="language-julia">handle(&quot;eval&quot;) do code
  eval(Meta.parse(code))
end</code></pre><p>This is a very simplified version of the <code>eval</code> handler that you can find in the Atom.jl source code. It simply evaluates whatever it&#39;s given and returns the result – in this case, <code>4</code>.</p><p>Often we want to do something with that return result in Atom – in this case, we&#39;d like to display the result. We don&#39;t need to change anything on the Julia side to accomplish this; we can just use the <code>rpc</code> function from JS:</p><pre><code class="language-coffeescript">client.rpc(&#39;eval&#39;, &#39;2+2&#39;).then (result) =&gt;
  console.log data</code></pre><p>This call sends the <code>eval</code> message, pulls the <code>result</code> field out of the returned JSON, and displays the result, <code>4</code>, in the console.</p><p>This approach is exactly how Atom gets evaluation results, autocompletion and more from Julia – so it&#39;s easy to find more examples spread throughout the <a href="https://github.com/JunoLab/atom-julia-client/tree/master/lib">julia-client</a> and <a href="https://github.com/JunoLab/Atom.jl/tree/master/src">Atom.jl</a> source code.</p><p>As a first project, try implementing an Atom command (see the Atom docs) which sends this message to Julia, as well as adding the Julia handler above to Atom.jl. (You&#39;ll want to use a type other than <code>eval</code> to avoid clashes with actual evaluation.)</p><h2><a class="nav-anchor" id="Sending-messages-from-Julia-1" href="#Sending-messages-from-Julia-1">Sending messages from Julia</a></h2><p>Julia has a similar mechanism to talk to Atom via the function</p><pre><code class="language-julia">Atom.@msg type(args...)</code></pre><p>Handlers are defined on the Atom side as follows:</p><pre><code class="language-coffeescript">client.handle &#39;log&#39;, (args...) -&gt;
  console.log args</code></pre><p>It&#39;s also possible for Julia to wait for a response from Atom, using the <code>rpc</code> function.</p><pre><code class="language-coffeescript">client.handle &#39;echo&#39;, (data) -&gt;
  data</code></pre><p>(It&#39;s very easy to add this code to <code>julia-client</code>&#39;s <a href="https://github.com/JunoLab/atom-julia-client/blob/master/lib/julia-client.coffee"><code>activate</code> function</a> if you want to try this out.)</p><p>Calling the following from the REPL:</p><pre><code class="language-julia">Atom.@rpc echo(Dict(:a=&gt;1, :b=&gt;2))</code></pre><p>will return <code>Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2)</code>. The data was passed to Atom and simply returned as-is. Try changing the handler to modify the data before returning it.</p><p>This mechanism is how Julia commands like <code>Atom.select()</code> are implemented, and in general it makes it very simple for Julia to control the Atom frontend – see <a href="https://github.com/JunoLab/Atom.jl/blob/master/src/frontend.jl">frontend.jl</a> and <a href="https://github.com/JunoLab/atom-julia-client/blob/master/lib/frontend.coffee">frontend.coffee</a></p><h2><a class="nav-anchor" id="Debugging-and-Learning-1" href="#Debugging-and-Learning-1">Debugging and Learning</a></h2><p>A good way to get a handle on this stuff is just to use <code>console.log</code> and <code>@show</code>, on the Atom and Julia sides respectively, to take a peek at what&#39;s going over the wire. For example, it&#39;s easy to change the above Julia handler to</p><pre><code class="language-julia">handle(&quot;eval&quot;) do data
  @show data
  @show Dict(:result =&gt; eval(parse(data[&quot;code&quot;])))
end</code></pre><p>This will show you both the data being sent to Julia (in the example above, <code>Dict(&quot;code&quot;=&gt;&quot;2+2&quot;)</code>) and the data being sent back to Atom (<code>Dict(:result =&gt; 4)</code>). Modifying say, the completions handler in a similar way will show you what completion data Julia sends back to Atom (there will probably be a lot, so try looking at specific keys, for example).</p><p>You don&#39;t need to reload Atom or restart the Julia client every time you make a change like this. If you open a file from the <code>Atom.jl</code> source code, you should see from the status bar that Juno knows you&#39;re working with the <code>Atom</code> module (try evaluating <code>current_module()</code> if you&#39;re not sure). Evaluating <code>handlers</code> from within the <code>Atom</code> module will show you what message types are currently defined. If you change a handler, just press <code>C-Enter</code> to update it in place; you should see the effect of your update immediately next time the handler is triggered. For example, if you modify the <a href="https://github.com/JunoLab/Atom.jl/blob/master/src/eval.jl"><code>eval</code></a> handler as follows:</p><pre><code class="language-julia">handle(&quot;eval&quot;) do data
  println(data[&quot;code&quot;]) # &lt;- insert this line
  # ...</code></pre><p>and update it, you should find that the <em>next</em> time you evaluate you see the contents of the current editor dumped into the console. Thus, most features or fixes you&#39;d want to add to Juno can be made without a long edit – compile – run cycle.</p><footer><hr/><a class="previous" href="../juno_ci/"><span class="direction">Previous</span><span class="title">Juno&#39;s CI</span></a></footer></article></body></html>
